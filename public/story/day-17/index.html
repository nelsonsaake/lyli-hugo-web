<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Day 17 | Lyli</title>

<meta name="keywords" content="" />
<meta name="description" content="  11 : 17 am 
It&rsquo;s been some few days since I worked on this. The only thing left is telling if the program is finished.
The entire thing is multithreading. There is no way to know for sure, because the code is not procedural, it is reactive and event-driven.">
<meta name="author" content="">
<link rel="canonical" href="https://lyli.website/story/day-17/" />
<link href="/assets/css/stylesheet.min.3f0304495d619f7d80aa58fbfdc009bc6e4f0942427e1a4ea84d77aa42957f04.css" integrity="sha256-PwMESV1hn32Aqlj7/cAJvG5PCUJCfhpOqE13qkKVfwQ=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="https://lyli.website/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://lyli.website/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lyli.website/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lyli.website/apple-touch-icon.png">
<link rel="mask-icon" href="https://lyli.website/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.80.0" />


<meta property="og:title" content="Day 17" />
<meta property="og:description" content="  11 : 17 am 
It&rsquo;s been some few days since I worked on this. The only thing left is telling if the program is finished.
The entire thing is multithreading. There is no way to know for sure, because the code is not procedural, it is reactive and event-driven." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lyli.website/story/day-17/" />
<meta property="article:published_time" content="2020-12-16T11:17:42+00:00" />
<meta property="article:modified_time" content="2020-12-16T11:17:42+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Day 17"/>
<meta name="twitter:description" content="  11 : 17 am 
It&rsquo;s been some few days since I worked on this. The only thing left is telling if the program is finished.
The entire thing is multithreading. There is no way to know for sure, because the code is not procedural, it is reactive and event-driven."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Stories",
      "item": "https://lyli.website/story/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Day 17",
      "item": "https://lyli.website/story/day-17/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Day 17",
  "name": "Day 17",
  "description": "11 : 17 am  It\u0026amp;rsquo;s been some few days since I worked on this. The only thing left is telling if the program is finished. The entire thing is multithreading. There is no way to …",
  "keywords": [
    
  ],
  "articleBody": "11 : 17 am  It’s been some few days since I worked on this. The only thing left is telling if the program is finished. The entire thing is multithreading. There is no way to know for sure, because the code is not procedural, it is reactive and event-driven.\nThe components(QObjects) are kept alive, the threads are kept alive until explicit exit or quit command is given. The components only do work when a signal is sent. For example: the Renamer will only rename a file after a signal with the filename is received.\nThis of it as boats at a river bank. They are always there to ferry passengers, their work is never done because, they don’t know when the next passenger will arrive. Their work is never done because they can’t tell which passenger is the last passenger.\nThat’s the problem, I’m trying come up with a way of telling when the work is done so that all the components stop work. The way a normal program works is: it start follow the instruction to do some work then it stops. This is wait for everybody to finish before it stops. Or it can tell everybody to stop so it can stop. The problem is the component don’t know when the work will be finish so they will never stop. What I trying to do is find out when to tell them to stop, so the program or some part of the program can stop. This is also important to know when the work is finished so when alert the user that work is finished.\nOver the last few day I have been thinking about this, and I think I have an answer. The UI need to know when to tell the user the scan is finished.\nSo, the approach I’m taking about is, if the UI doesn’t receive any signals in about 30sec, it would send out a signal like a flare, if the signal returns in due time, then the UI will know it is finished. I can’t explain it any further because myself, I don’t fully understand yet.\n « Prev Page Next Page » ",
  "wordCount" : "359",
  "inLanguage": "en",
  "datePublished": "2020-12-16T11:17:42Z",
  "dateModified": "2020-12-16T11:17:42Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lyli.website/story/day-17/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Lyli",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lyli.website/favicon.ico"
    }
  }
}
</script>





<link rel="preconnect" href="https://fonts.gstatic.com">
<script data-ad-client="ca-pub-4771693215081441" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>



<script async src="https://www.googletagmanager.com/gtag/js?id=G-0K7SW0WREY"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0K7SW0WREY');
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lyli.website/" accesskey="h" title="Lyli (Alt + H)">Lyli</a>
            
        </div> <br>
        <ul id="menu" onscroll="menu_on_scroll()">
            <li>
                <a href="https://lyli.website/story/" title="Story">
                    <span>Story</span>
                </a>
            </li>
            <li>
                <a href="https://lyli.website/about/" title="About">
                    <span>About</span>
                </a>
            </li></ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">

    <h1 class="post-title">
      Day 17
    </h1>
    <div class="post-meta">December 16, 2020

</div>
  </header> 

  <div class="post-content">
<div class="story-time post-meta">  11 : 17 am </div>
<p>It&rsquo;s been some few days since I worked on this. The only thing left is telling if the program is finished.
The entire thing is multithreading. There is no way to know for sure, because the code is not procedural, it is reactive and event-driven.</p>
<p>The components(QObjects) are kept alive, the threads are kept alive until explicit exit or quit command is given. The components only do work when a signal is sent. For example: the <code>Renamer</code> will only rename a file after a signal with the filename is received.</p>
<p>This of it as boats at a river bank. They are always there to ferry passengers, their work is never done because, they don&rsquo;t know when the next passenger will arrive. Their work is never done because they can&rsquo;t tell which passenger is the last passenger.</p>
<p>That&rsquo;s the problem, I&rsquo;m trying come up with a way of telling when the work is done so that all the components stop work. The way a normal program works is: it start follow the instruction to do some work then it stops. This is wait for everybody to finish before it stops. Or it can tell everybody to stop so it can stop. The problem is the component don&rsquo;t know when the work will be finish so they will never stop. What I trying to do is find out when to tell them to stop, so the program or some part of the program can stop. This is also important to know when the work is finished so when alert the user that work is finished.</p>
<p>Over the last few day I have been thinking about this, and I think I have an answer. The UI need to know when to tell the user the scan is finished.</p>
<p>So, the approach I&rsquo;m taking about is, if the UI doesn&rsquo;t receive any signals in about 30sec, it would send out a signal like a flare, if the signal returns in due time, then the UI will know it is finished. I can&rsquo;t explain it any further because myself, I don&rsquo;t fully understand yet.</p>
<script type="application/javascript" src="https://gist.github.com/nelsonsaake/31b645a58cdf525f4cdc868e3471651a.js"></script>



<nav class="pagination" style="padding: 50px 0;">
     <a class="prev" href='/story/day-10/'>« Prev Page</a> 
     <a class="next" href='/story/day-22/'>Next Page »</a> 
</nav>
</div>

  <footer class="post-footer">
  </footer>
</article>
    </main><footer class="footer">
    <span>&copy; 2022 <a href="https://lyli.website/">Lyli</a></span>
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>



<script defer src="/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js" integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w="
    onload="hljs.initHighlightingOnLoad();"></script>
<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

</body>

</html>
